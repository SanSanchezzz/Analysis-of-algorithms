\chapter{Аналитический раздел}
\label{cha:analysis}

 Умножение матриц – это одна из основных вычислительных операций. Вычислительная сложность стандартного алгоритма умножения матриц порядка N составляет $O(N^3)$. Но существуют более сложные алгоритмы, которые дают лучший результат. Целью данной работы является сравнение стандартного алгоритма и алгоритма Винограда. 


\section{Описание задачи}
\hfill

Пусть даны две прямоугольные матрицы $A[M \times N]$ и $B[N \times Q]$:
$$
A =
\begin{bmatrix} 
a_{11} & a_{12} & \cdots & a_{1n} \\
    a_{21} & a_{22} & \cdots & a_{2n} \\ 
\vdots & \vdots & \ddots & \vdots \\ 
a_{m1} & a_{m2} & \cdots & a_{mn}
\end{bmatrix}
B =   
\begin{bmatrix} 
b_{11} & b_{12} & \cdots & b_{1q} \\
b_{21} & b_{22} & \cdots & b_{2q} \\ 
\vdots & \vdots & \ddots & \vdots \\ 
    b_{n1} & b_{n2} & \cdots & b_{nq}
\end{bmatrix}
$$
Тогда матрица $C[M \times Q]$ -- произведение матриц:
$$
C = 
\begin{bmatrix} 
    c_{11} & c_{12} & \cdots & c_{1q} \\
c_{21} & c_{22} & \cdots & c_{2q} \\ 
\vdots & \vdots & \ddots & \vdots \\ 
    c_{m1} & c_{m2} & \cdots & c_{mq}
\end{bmatrix},
$$
в которой каждый элемент вычисляется по формуле 1: 
$$c_{ij} = \sum_{k=1}^n a_{ik}b_{kj}, ~(i=1, 2, \ldots l;j=1, 2, \ldots n)~~(1)$$

Операция умножения двух матриц выполнима только в том случае, если число столбцов в первом сомножителе равно числу строк во втором; в этом случае говорят, что матрицы ''согласованы''.

В данной работе необходимо оценить и подтвердить трудоемкость алгоритмов, обратимся к определению. 

\textbf{Трудоемкость алгоритма}-- это зависимость количества операций от объема обрабатываемых данных.
Модель вычислений:
\begin{enumerate}
\item Цена едичных операций. Пусть у следующих операций трудоемкость равна 1:
$$+~,-~,*~,/~,\%~,=~,==~,!=~,<>~,<=~,>=~,[]~,+=$$
\item Трудоемкость улсовного перехода примем за единицу, при этом условие вычисляется по пункту 1. 
\item Трудоемкость циклов, например цикла for:
$$f_{for} = f_{init}+f_{comp}+N*(f_{body}+f_{inc}+f_{comp})$$
\end{enumerate}


\section{Пути решения}
\hfill

Сложность вычисления произведения матриц порядка N по определению составляет составляет $O(N^3)$, однако существуют более эффективные алгоритмы, применяющиеся для перемножения матриц. 

Первый алгоритм быстрого умножения больших матриц был разработан Фолькером Штрассеном в 1969. На основе данного алгоритма Штрассена разработаны другие, которые улучшают его трудоемкость, однако в силу простоты  именно алгоритм Штрассена остаётся одним из практических алгоритмов умножения больших матриц. 

В дальнейшем было разработано еще множество различных алгоритмов. Однако эти алгоритмы носили теоретический, в основном приближённый характер. В силу неустойчивости алгоритмов приближённого умножения в настоящее время они не используются на практике.

В 1990 Копперсмит и Виноград опубликовали алгоритм, и на сегодняшний день алгоритма Винограда является наиболее быстрым. Именно этот алгоритм и его оптимизация выбраны для дальнейшего исследования в данной работе.
В качестве примера рассмотрим два вектора длинной 4: $U = (u_1, u_2, u_3, u_4)$ и $V = (v_1, v_2, v_3, v_4)$. Их скалярное произведение равно:
\begin{equation}
    U\times{}V = u_1\cdot{}v_1 + u_2\cdot{}v_2 + u_3\cdot{}v_3 + u_3\cdot{}v_4
\end{equation}
Левую часть равенства (1.3) можно записать в виде:
\begin{equation}
    (u_1 + v_2)\cdot{}(u_2 + v_1) + (u_3 + v_4)\cdot{}(u_4 + v_3) - u_1\cdot{}u_2 - u_3\cdot{}u_4 - v_1\cdot{}v_2 - v_3\cdot{}v_4
\end{equation}
Выражение (1.4) допускает предварительную обработку в случае умножения двух матриц. Для каждой строки можно вычислить выражение (1.5):
\begin{equation}
    u_1\cdot{}u_2 + u_3\cdot{}u_4
\end{equation}
А для каждого столбца - выражение (1.6):
\begin{equation}
    v_1\cdot{}v_2 + v_3\cdot{}v_4
\end{equation}
Таким образом, выходит, что над заранее обработанными данными необходимо выполнить лишь 2 умножения, 5 сложений и 2 вычитания, но данный алгоритм имеет один ньюанс, который заключается в операции добавления элементов в случае нечетных векторов.
В ситуации, когда вектора нечетные, необходимо совершить добавление произведения (n - 1, i) элементов матриц, где i - иттерация, а (n-1) - длина столбца в первой матрице.


\newpage

\section{Выводы}
Для теоретической оценки вышеупомянотых алгоритмов реализуем их и проверим всё эксперементально.
