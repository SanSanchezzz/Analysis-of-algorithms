\chapter{Технологический раздел}
\label{cha:impl}

В данном разделе приводятся описания требований к программному обеспечению, средства реализации, листинги кода и описания тестирования.
\section{Требования к программному обеспечению}
Требования к вводу:
\begin{itemize}
    \item на вход подается массив;
\end{itemize}
Требования к выводу:
\begin{itemize}
    \item на выход подаются массивы, отсортированные разными алгоритмами;
\end{itemize}
\section{Средства реализации}
В качестве языка программирования мною был выбран python, так как данный язык программирования позволяет максимально лаконично и демонстративно реализовать необходимые алгоритмы.
\section{Листинги кода}

В листингах 3.1 - 3.3 приведена реализация описанных алгоритмов.
\begin{lstlisting}[caption=Поразрядная сортировка]
	n = pow(digit, n)
    	i = 1
    	while (i < n):
		sort = [[] for k in range(digit)]

		for x in array:
			sort[get_digit(x, i)].append(x)

		count = len(array)
		array = [0] * count
		u = 0
		w = 0
		for k in range(digit):
			for j in range(len(sort[k])):
				if (sort[k][j] < 0):
					array[w] = sort[k][j]
					w += 1
				else:
					array[u + neg] = sort[k][j]
					u += 1
		i *= 10
\end{lstlisting}

\begin{lstlisting}[caption=Сортировка вставками]
	for i in range(1, len(array)):
		j = i - 1
		key = array[i]
		while array[j] > key and j >= 0:
			array[j + 1] = array[j]
			j -= 1
		array[j + 1] = key
\end{lstlisting}

\noindent\begin{minipage}{\textwidth}
\begin{lstlisting}[caption=Быстрая сортировка]
def partition(nums, low, high):
    middle = nums[(low + high) // 2]
    i = low - 1
    j = high + 1
    while True:
        i += 1
        while nums[i] < middle:
            i += 1
        j -= 1
        while nums[j] > middle:
            j -= 1
        if i >= j:
            return j
        nums[i], nums[j] = nums[j], nums[i]

def quicking_sort(items, low, high):
    if low < high:
        split_index = partition(items, low, high)
        quicking_sort(items, low, split_index)
        quicking_sort(items, split_index + 1, high)

def quick_sort(nums):
    quicking_sort(nums, 0, len(nums) - 1)
\end{lstlisting}
\end{minipage}

\section{Описание тестирования}
Для тестирования программы были подготовлены данные, представленные в таблице 1.
	\begin{center}
		\begin{tabular}{  | c | c | }
			\hline
			\textbf{Маcсив}& \textbf{Ожидаемый результат} \\ \hline
			$\begin{bmatrix} 
   			1&2&3 \\
			\end{bmatrix}$ & 
			$\begin{bmatrix} 
   			1&2&3 \\
			\end{bmatrix}$ \\
			\hline
			
			$\begin{bmatrix} 
   			3&2&1 \\
			\end{bmatrix}$ & 
			$\begin{bmatrix} 
   			1&2&3 \\
			\end{bmatrix}$ \\
			\hline
			
			$\begin{bmatrix} 
   			1&2&-3 \\
			\end{bmatrix}$ & 
			$\begin{bmatrix} 
   			-3&1&2 \\
			\end{bmatrix}$ \\
			\hline
			
			$\begin{bmatrix} 
   			1&0&-3 \\
			\end{bmatrix}$ & 
			$\begin{bmatrix} 
   			-3&0&1 \\
			\end{bmatrix}$ \\
			\hline
			
			$\begin{bmatrix} 
   			0 \\
			\end{bmatrix}$ & 
			$\begin{bmatrix} 
   			0 \\
			\end{bmatrix}$ \\
			\hline
		\end{tabular}
		
		\hfill
		
		Таблица 1.
		Подготовленные тестовые данные.  
	\end{center}
	
Все тесты были успешно пройдены.
\section{Вывод}

Были сформулированы требования к ПО, выбраны средства реализации и подготовлены тестовые данные.
%%%% mode: latex
%%%% TeX-master: "rpz"
%%%% End:
