\chapter{Аналитический раздел}
\label{cha:analysis}

        Под сортировкой обычно понимают процесс перестановки объектов данного множества в определенном порядке. Цель сортировки -- облегчить последующий поиск элементов в отсортированном множестве. Таким образом, сортировки присутствуют во всех областях. 
        
        \section{Описание задачи}
        \hfill
        
        \textbf{Сортировка} -- это процесс упорядочения некоторого множества элементов, на котором определены отношения порядка >, <, >=, <= (по возрастанию или убыванию).
        
        \hfill
        
        При выборе алгоритмов сортировки необходимо поставить перед собой вопрос. Существует ли наилучший алгоритм? Имея приблизительные характеристики входных данных, можно подобрать метод, работающий оптимальным образом.
        
        \hfill
        
        Рассмотрим параметры, по которым будет производиться оценка алгоритмов.
        \begin{enumerate}
	\item Число операций сортировки (сравнения и перемещения) -- параметры, характеризующие трудоемкость алгоритма.
	\item Время работы -- скорость работы на различных длинах массивов. Некоторые алгоритмы сортировки зависят от данных, например, если первоначально данные упорядочены, время может значительно сократиться, тогда как другие методы оказываются нечувствительными к этому свойству. 
	
	Чтобы учитывать этот факт, будет рассматривать: лучшие, худшие и произвольные случаи. 
	\end{enumerate}
	
	Как было сказано, в данной работе необходимо оценить и подтвердить трудоемкость алгоритмов, обратимся к определению. 
        
        \textbf{Трудоемкость алгоритма}-- это зависимость количества операций от объема обрабатываемых данных.
        Модель вычислений:
        \begin{enumerate}
		\item Цена едичных операций. Пусть у следующих операций трудоемкость равна 1:
		$$+~,-~,*~,/~,\%~,=~,==~,!=~,<>~,<=~,>=~,[]~,+=$$
		\item Трудоемкость улсовного перехода примем за единицу, при этом условие вычисляется по пункту 1. 
		\item Трудоемкость циклов, например цикла for:
		$$f_{for} = f_{init}+f_{comp}+N*(f_{body}+f_{inc}+f_{comp})$$
	\end{enumerate}

\section{Пути решения}
\hfill

Сортировка — один из базовых видов активности или действий, выполняемых над предметами. Ещё в детстве детей учат сортировать, развивая мышление. Компьютеры и программы — тоже не исключение. И поэтому в настоящее время существует огромное количество алгоритмов сортировок, которые были придуманы и используются для разных задач.

\section{Описание алгоритмов}
В данном разделе будут описаны выбранные алгоритмы.
\subsection{Быстрая сортировка}
Краткое описание алгоритма:
\begin{enumerate}
	\item выбирается элемент, называемый опорным;
	\item остальные элементы сравниваются с опорным, на основании сравнения меньшие опорного перемещаются левее него, а большие или равные - правее;
	\item рекурсивно упорядочиваются подмассивы, лежащие слева и справа от опорного элемента.
\end{enumerate}
Для этого алгоритма самый лучший случай — если в каждой итерации каждый из подмассивов делился бы на два равных по величине массива. В результате количество сравнений, производимых быстрой
сортировкой, было бы равно значению рекурсивного выражения 𝐶𝑁 = 2𝐶𝑁/2+𝑁, что в явном выражении
дает примерно 𝑁 * 𝑙𝑜𝑔(𝑁) сравнений. Это дало бы наименьшее время сортировки.
Худшим случаем будет такой, при котором на каждом этапе массив будет разделяться на вырожденный подмассив из одного опорного элемента и на подмассив из всех остальных элементов.
Расчет трудоемкости:
При анализе сложности циклических алгоритмов рассчитывается трудоемкость итераций и их количество в наихудшем и наилучшем случаях. Однако не получится применить такой подход к рекурсивной
функции, так как в результате будет получено рекуррентное соотношение. Рекуррентные отношения не
позволяют оценить сложность — мы не можем их просто так сравнивать, а значит, и сравнивать эффективность соответствующих алгоритмов.
С помощью общего метода решений рекуррентных соотношений оценим трудоемкость алгоритма.
Исходные данные разделяются на две части, обе из которых обрабатываются: 𝑎 = 2 (подзадачи), 𝑏 = 2
(части), 𝑛
𝑙𝑜𝑔𝑏𝑎 = 𝑛 - скорость роста функции разделения задачи и компоновки результата. На соединение
результатов будет затрачено 𝑂(𝑛), поэтому 𝑓𝑛 = 𝑛.
Для расчета трудоемкости лучшего случая используем второй случай основной теоремы о рекуррентных соотношениях: 𝑇
𝑞𝑢𝑖𝑐𝑘𝑠𝑜𝑟𝑡
𝑛 = 𝑂(𝑛
𝑙𝑜𝑔𝑏𝑎
· 𝑙𝑜𝑔𝑛) = 𝑂(𝑛 · 𝑙𝑜𝑔𝑛).
В худшем случае каждое разделение даёт два подмассива размерами 1 и 𝑛 − 1 , то есть при каждом
рекурсивном вызове больший массив будет на 1 короче, чем в предыдущий раз. Такое может произойти,
если в качестве опорного на каждом этапе будет выбран элемент либо c наименьшим, либо наибольшим
индексом из всех обрабатываемых. При простейшем выборе опорного элемента — первого или последнего
в массиве, — такой эффект даст уже отсортированный (в прямом или обратном порядке) массив, для
среднего или любого другого фиксированного элемента «массив худшего случая» также может быть
специально подобран. В этом случае общее время работы составит
∑︁𝑛𝑖=0(𝑛 − 𝑖) ≈ 𝑂(𝑛*2)
операций, то есть сортировка будет выполняться за квадратичное время.

\subsection{Сортировка вставками}
Краткое описание алгоритма:
\begin{enumerate}
	\item выбирается один из элементов входных данных;
	\item выбранный элемент вставляется на нужную позицию в уже отсортированной последовательности;
	\item п 1,2 выполняются, пока набор входных данных не будет исчерпан.
\end{enumerate}
Сортировка вставками не использует обмены. Сложность алгоритма измеряется числом сравнений
и равна 𝑂(𝑛
2
). Наилучший случай – когда исходная последовательность уже отсортирована. Тогда на
i-ом проходе вставка производится в точке 𝐴[𝑖], а общее число сравнений равно n-1. Наихудший случай
возникает, когда список отсортирован по убыванию. Тогда каждая вставка происходит в точке 𝐴[0] и
требует i сравнений; общее число сравнений равно n(n-1)/2.
Расчет трудоемкости:
𝑓𝑏𝑒𝑠𝑡 = 2 + (𝑛 − 1)(7 + 0 · 9 + 3) = 2 + 10(𝑛 − 1)
𝑓𝑤𝑜𝑟𝑠𝑡 = 2 + (𝑛 − 1)(7 + (𝑛 − 1) · 9 + 3) = 9(𝑛 − 1)2 + 10(𝑛 − 1) + 2 = 9𝑛
2 − 8𝑛 + 1
где 𝑛 - длина сортируемой последовательности.

\subsection{Поразрядная сортировка}
Алгоритм поразрядной сортировки не использует сравнений самих сортируемых элементов. Ключ,
по которому происходит сортировка, разделяется на части - разряды ключа. Например, число можно
разделить по цифрам, слово - по буквам.
Перед началом непосредственно сортировки необходимо вычислить два параметра: k - количество
разрядов в самом длинном ключе, m - разрядность данных: количество возможных значений разряда
ключа. На каждом шаге алгоритма числа сортируются таким образом, чтобы они были упорядочены
по последним i разрядам/битам, то есть на каждом шаге достаточно сортировать элементы по новому
разряду/биту.
Краткое описание алгоритма:
\begin{enumerate}

	\item создаются пустые списки, количество которых равно числу m;
	\item исходные числа распределяются по этим спискам в зависимости от величины младшего разряда (по
возрастанию);
	\item числа собираются в единый список (который замещает теперь исходный) в той последовательности,
в которой они находятся после распределения по спискам;
	\item пункты 2 и 3 повторяются для всех более старших разрядов поочередно (и так до k).
Расчет трудоемкости:
𝑓 = 4 + (2 + 4𝑘) + 4 + 2 + 𝑚 · (4 + 5𝑛 + 10) + 2 + 4𝑘 = 12 + 4𝑘 + 𝑚(14 + 5𝑛) + 2 + 4𝑘 = 5𝑘𝑛 + 8𝑚 + 14𝑘 + 14 ,
где 𝑛 - длина сортируемой последовательности.
Сложность поразрядной сортировки не зависит от того, как упорядочены входные данные, так как не
основана на сравнении непосредственно самих элементов последовательности.
\section{Выводы}
Для теоретической оценки вышеупомянотых алгоритмов реализуем их и проверим всё эксперементально.
